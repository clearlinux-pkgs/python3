From 2fc22011d5ce9dd6dc4f69fed554a7149ac89b4d Mon Sep 17 00:00:00 2001
From: William Douglas <william.douglas@intel.com>
Date: Fri, 30 Oct 2015 16:16:06 -0400
Subject: [PATCH] Replace getrandom syscall with RDRAND instruction

Instead of using getrandom which can block and cause issues when
entropy is low, switch to using the RDRAND instruction. This tests for
the the availability of the RDRAND instruction with gcc intrinsics and
falls back to the syscall method if the instruction isn't available.
---
 Python/random.c | 62 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 1 file changed, 62 insertions(+)

diff --git a/Python/random.c b/Python/random.c
index ea09e84..afe479d 100644
--- a/Python/random.c
+++ b/Python/random.c
@@ -7,6 +7,11 @@
 #    include <sys/stat.h>
 #  endif
 #  ifdef HAVE_GETRANDOM_SYSCALL
+#    pragma GCC push_options
+#    pragma GCC target("rdrnd")
+#    include <cpuid.h>
+#    include <immintrin.h>
+#    include <stdint.h>
 #    include <sys/syscall.h>
 #  endif
 #endif
@@ -108,6 +113,50 @@ py_getentropy(unsigned char *buffer, Py_ssize_t size, int fatal)
 #else   /* !HAVE_GETENTROPY */
 
 #ifdef HAVE_GETRANDOM_SYSCALL
+
+static int
+py_getrdrand(void *buffer, Py_ssize_t size, int raise)
+{
+    int n;
+    int f = 0;
+
+    while (0 < size) {
+        uint32_t val;
+
+        if (raise) {
+            Py_BEGIN_ALLOW_THREADS
+            n = _rdrand32_step(&val);
+            Py_END_ALLOW_THREADS
+        }
+        else {
+            n = _rdrand32_step(&val);
+        }
+
+        if (!n) {
+            /* retry rdrand up to a point*/
+            if (f < 10) {
+                f++;
+                continue;
+            } else {
+                if (raise) {
+                    PyErr_SetString(PyExc_RuntimeError, "Repeated calls to rdrand failed");
+                } else {
+                    Py_FatalError("Repeated calls to rdrand failed");
+                    return -1;
+                }
+            }
+        }
+
+        for (uint i = 0; i < sizeof(uint32_t) && 0 < size; i++) {
+            char *t = ((char *)(&val)) + i;
+            memcpy(buffer, t, sizeof(char));
+            buffer++;
+            size--;
+        }
+    }
+    return 1;
+}
+
 static int
 py_getrandom(void *buffer, Py_ssize_t size, int raise)
 {
@@ -117,6 +166,13 @@ py_getrandom(void *buffer, Py_ssize_t size, int raise)
     /* Use /dev/urandom, block if the kernel has no entropy */
     const int flags = 0;
     int n;
+    unsigned int eax, ebx, ecx, edx;
+
+    /* Use RDRAND instead if available */
+    __cpuid (1, eax, ebx, ecx, edx);
+    if (ecx & bit_RDRND) {
+        return py_getrdrand(buffer, size, raise);
+    }
 
     if (!getrandom_works)
         return 0;
@@ -414,3 +470,9 @@ _PyRandom_Fini(void)
     dev_urandom_close();
 #endif
 }
+
+#ifndef MS_WINDOWS
+#  ifdef HAVE_GETRANDOM_SYSCALL
+#    pragma GCC pop_options
+#  endif
+#endif
-- 
2.6.3

