From e305ad02b74e605f9196dc86124a4923df6fc9c4 Mon Sep 17 00:00:00 2001
From: William Douglas <william.douglas@intel.com>
Date: Fri, 30 Oct 2015 16:16:06 -0400
Subject: [PATCH] Replace getrandom syscall with RDRAND instruction

Instead of using getrandom which can block and cause issues when
entropy is low, switch to using the RDRAND instruction. This tests for
the the availability of the RDRAND instruction with gcc intrinsics and
falls back to the syscall method if the instruction isn't available.
---
 Python/random.c | 64 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 1 file changed, 64 insertions(+)

diff --git a/Python/random.c b/Python/random.c
index 07dacfe..4fd3264 100644
--- a/Python/random.c
+++ b/Python/random.c
@@ -12,6 +12,11 @@
 #  ifdef HAVE_GETRANDOM
 #    include <sys/random.h>
 #  elif defined(HAVE_GETRANDOM_SYSCALL)
+#    pragma GCC push_options
+#    pragma GCC target("rdrnd")
+#    include <cpuid.h>
+#    include <immintrin.h>
+#    include <stdint.h>
 #    include <sys/syscall.h>
 #  endif
 #endif
@@ -120,6 +125,50 @@ py_getentropy(unsigned char *buffer, Py_ssize_t size, int fatal)
 #define PY_GETRANDOM 1
 
 static int
+py_getrdrand(void *buffer, Py_ssize_t size, int raise)
+{
+    int n;
+    int f = 0;
+
+    while (0 < size) {
+        uint32_t val;
+
+        if (raise) {
+            Py_BEGIN_ALLOW_THREADS
+            n = _rdrand32_step(&val);
+            Py_END_ALLOW_THREADS
+        }
+        else {
+            n = _rdrand32_step(&val);
+        }
+
+        if (!n) {
+            /* retry rdrand up to a point*/
+            if (f < 10) {
+                f++;
+                continue;
+            } else {
+                if (raise) {
+                    PyErr_SetString(PyExc_RuntimeError, "Repeated calls to rdrand failed");
+                } else {
+                    Py_FatalError("Repeated calls to rdrand failed");
+                    return -1;
+                }
+            }
+        }
+
+        for (uint i = 0; i < sizeof(uint32_t) && 0 < size; i++) {
+            char *t = ((char *)(&val)) + i;
+            memcpy(buffer, t, sizeof(char));
+            buffer++;
+            size--;
+        }
+    }
+    return 1;
+}
+
+
+static int
 py_getrandom(void *buffer, Py_ssize_t size, int raise)
 {
     /* Is getrandom() supported by the running kernel?
@@ -133,6 +182,15 @@ py_getrandom(void *buffer, Py_ssize_t size, int raise)
      * GRND_NONBLOCK flag. */
     const int flags = GRND_NONBLOCK;
     int n;
+#ifdef HAVE_GETRANDOM_SYSCALL
+    unsigned int eax, ebx, ecx, edx;
+
+    /* Use RDRAND instead if available */
+    __cpuid (1, eax, ebx, ecx, edx);
+    if (ecx & bit_RDRND) {
+        return py_getrdrand(buffer, size, raise);
+    }
+#endif
 
     if (!getrandom_works)
         return 0;
@@ -460,3 +518,9 @@ _PyRandom_Fini(void)
     dev_urandom_close();
 #endif
 }
+
+#ifndef MS_WINDOWS
+#  ifdef HAVE_GETRANDOM_SYSCALL
+#    pragma GCC pop_options
+#  endif
+#endif
-- 
2.4.11

